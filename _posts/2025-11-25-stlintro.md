---
layout: post
title: STL 소개
date: 2025-11-25
categories: [C++]
tags: [C++,STL]
---
#### STL 구성요소
1. 컨테이너(Container) : 자료구조
2. 반복자(Iterator)
3. 알고리즘(Algorithm) : 정렬, 삭제, 검색, 연산등 일반화된 기능 제공하는 함수템플릿
4. 함수 객체(Funtion Object) : 컨테이너와 알고리즘에 클라이언트 정책 반영 위해
5. 어댑터(Adaptor) : 인터페이스를 변경해 새로운 인터페이스를 갖는 구성요소로 변경?
6. 할당기(Allocator) : 컨테이너의 메모리 할당 정책을 캡슐화한 클래스 객체
#### STL의 세가지 특징
1. 효율성
2. 일반화 프로그램(재사용성)
3. 확장성
#### 컨테이너
`#include<vector>,#include<deque>,#include<list>......`

표준 시퀀스 vs 표준 연관
1. 표준 시퀀스 컨테이너(Standard sequence container) : 원소가 자신만의 삽입위치(순서) 가짐
	1. vector, deque, list
2. 표준 연관 컨테이너(Standard associative container) : 삽입순서 관계없이 정렬 기준에 따라 원소 순서 결정
	1. set, multiset, map, multimap

배열 기반 vs 노드 기반
1. 배열 기반 컨테이너(array-based container) : 데이터 여러개가 하나의 메모리 단위에 저장
	1. vector,deque
2. 노드 기반 컨테이너(node-based container) : 데이터 하나를 하나의 메모리에 저장
	1. list, set, multiset, map, multimap
예시
1. 시퀀스 컨테이너
	1. 맨 끝에 원소 추가 제거 위해 `push_back()`, `pop_back()`함수 지원
	2. `operator[]`로 원소 접근
2. 모든 컨테이너는 원소 개수 반환하는 `size()`함수 가짐
3. 

#### 반복자

1. 두가지 기능
	1. `*`연산자 : 객체 가리키고 접근
	2. `++`, `!=`, `==` 연산자 : 다음 원소로 이동, 모든 원소 순회 가능
2. 원소(객체)의 집합 : sequence(순차열)
3. STL의 모든 컨테이너 : 자신만의 반복자 제공 - `begin()`, `end()`멤버로 맨앞, 맨끝 접근 가능
	1. `begin()`, `end()` : end는 원소가 아니고 끝을 표시(past-the-end)
4. 컨테이너의 일부분 `[iter,end)`도 sequence
5. 예시 : `vector<int>::iterator iter;`
6. 반복자의 다섯 범주
	1. 입력 반복자(input iterator) : 현 위치 원소 한번만 읽을 수 있음
		1. istream
	2. 출력 반복자(output iterator) : 현 위치 원소 한번만 쓸 수 있음
		1. ostream
	3. 순방향 반복자(forward iterator) : 입/출력 반복자기능 , 순방향이동(`++`)가능, 재할당될 수 있음
	4. 양방향 반복자(bidirectional iterator) : 순방향 반복자 기능 , 역방향이동(`--`)가능
		1. list, set, multiset, map, multimap
	5. 임의 접근 반복자(random access iterator) : 양방향 반복자 기능 , `+`,`-`,`+=`,`-=`,`[]`연산 가능
		1. vector, deque
#### 알고리즘
`#include\<algorithm>......`
1. 알고리즘의 7가지 범주
	1. nonmodifying algorithms : 원소를 수정하지 않는 알고리즘
	2. modifying algorithms : 원소를 수정하는 알고리즘
	3. removing algorithms : 제거 알고리즘
	4. mutating algorithms : 변경 알고리즘
	5. sorting algorithms : 정렬 알고리즘
	6. sorted range algorithms : 정렬된 범위 알고리즘
		1. numeric algorithms : 수치 알고리즘
2. find 함수 사옹 예시 - 순방향 반복자 요구
	1. `iter = find(vec.begin(),vec.end(),10);`
	2. 없으면 `iter == vec.end()`임
3. sort 함수 예시 - 임의 접근 반복자 요구
	1. `sort(vec.begin(),vec.end());`

#### 함수 객체

1. 클라이언트가 정의한 동작을 다른 구성요소에 반영
2. 예시: `less<>`, `greater<>`와 sort의 조합
3. `sort(vec.begin(),vec.end(),less<int>());`
4. `sort(b,e,f)`와 `sort(b,e)`는 다른 버전, f 가 없는건 기본값이 less로 작동

#### 어댑터
`#include<functional>` - not2
1. 구성요소의 인터페이스를 변경
2. 컨테이너 어댑터, 반복자 어댑터, 함수 어댑터
	1. 컨테이너 어댑터 : stack, queue, priority_queue
	2. 반복자 어댑터 : reverse_iterator, back_insert_iterator, front_insert_iterator, insert_iterator
	3. 함수 어댑터 : 바인더(binder), 부정자(negator), 함수 포인터 어댑터(adaptors for pointers to funcions)
3. 컨테이너 어댑터 예시 : stack
	1. 일반 컨테이너를 LIFO로 변경
	2. empty, push_back, pop_back, size, back 인터페이스(멤버함수)를 지원하는 컨테이너는 모두 가능
		1. ex : deque, vector
		2. 기본값은 deque
4. 반복자 어댑터 예시 : reverse_iterator
	1. `reverse_iterator<vector<int>::iterator> riter(vec.end());`
		1. riter가 `vec.end()`의 값(past-the-end)가 아닌 마지막 원소를 가리킴에 주의
		2. 정방향 반복자와의 호환을 위해
			1. 정방향 반복자 사용 도중 역방향으로 변환해서 진행하면 정확하게 왔던길만 되돌아감
		3. `++riter`는 반대방향으로 진행
	2. 모든 컨테이너는 자신의 역방향 반복자를 typedef로 정의, `rbegin()`/`rend()`갖기 때문에 다음과 같이 사용도 가능
		1. `vector<int>::reverse_iterator riter(vec.rbegin());`
5. 함수 어댑터 예시 : not2 (단항일 경우 not1)
	1. `not2(less<int>())(1,2));` -> 함수 객체 `less<int>()(1,2)`와 반대로 0 반환
		1. godbolt에서 안돼서 not_fn사용했음

#### 할당기
- 메모리 할당 정보와 정책을 캡슐화
- 메모리 할당 연산자는 원래 오버로딩 가능(operator new(), operator delete())
- 사용자가 직접 지정 가능하지만 보통 기본 할당기로 충분
- 기본 할당기 : allocator<타입>
- vector에 사용된 예시
	- `vector<int, allocator<int>> v;`
	- `vector<int>와` 같음



