---
layout: post
title: STL 학습에 필요한 사전 지식
date: 2025-11-21
categories: [C++]
tags: [C++,STL]
---

#### 연산자 오버로딩
직관성, 가독성을 위해 사용
`p1+p2` 는 `p1.operator+(p2)`와 같다
return 타입 내가 알아서 설정하면 됨(`+`를 `==` 처럼 연산하게 만들 수도 있음)



#### 단항 연산자 오버로딩
가능한 연산자 : `!`, `&`, `~`(보수연산자: 1->0,0->1), `*`, `+`, `-`, `++`, `--`, 형변환 연산자

전위, 후위 구분
- `++p1`: 전위, `p1++`: 후위
- 선언
	- 전위: `operator++()`
	- 후위: `operator++(int)`
- 사용
	- 전위: `p1.operator++()`
	- 후위: `p1.operator++(0)`
		- 0은 구분할라고 쓰는 dummy 정수 아무거나 넣은 것

#### 이항 연산자 오버로딩
가능한 연산자

| 연산자    | 이름                |
| --------- | ------------------- |
| **,**     | Comma               |
| **!=**    | 같지 않음           |
| **%**     | 모듈러스            |
| **%=**    | 모듈러스/할당       |
| **&**     | 비트 AND            |
| **&&**    | 논리적 AND          |
| **&=**    | 비트 AND/할당       |
| **`*`**   | 곱하기              |
| **`*=`**  | 곱하기/할당         |
| **+**     | 더하기              |
| **+=**    | 더하기/할당         |
| **-**     | 빼기                |
| **-=**    | 빼기/할당           |
| **->**    | 멤버 선택           |
| **`->*`** | 멤버 포인터 선택    |
| **/**     | 나누기              |
| **/=**    | 나누기/할당         |
| **<**     | 보다 작음           |
| **<<**    | 왼쪽 시프트         |
| **<<=**   | 왼쪽 시프트/할당    |
| **<=**    | 보다 작거나 같음    |
| **=**     | 양도                |
| **==**    | Equality            |
| **>**     | 보다 큼             |
| **>=**    | 크거나 같음         |
| **>>**    | 오른쪽 시프트       |
| **>>=**   | 오른쪽 시프트/할당  |
| **^**     | 배타적 OR           |
| **^=**    | 배타적 OR/할당      |
| **\|**    | 포괄적 비트 OR      |
| **\|=**   | 포괄적 비트 OR/할당 |
| **\|**    | 논리적 OR           |

연산자 왼쪽이 this, 오른쪽이 arg

#### 전역함수로 오버로딩 vs 멤버함수로 오버로딩

전역함수: `operator+(p1,p2)`
멤버함수: `p1.operator+(p2)`

전역함수는 구현할 때 멤버에 접근 못함
- friend 함수로 선언
	- 캡슐화를 저해
- Getter, Setter함수로 접근
- 왼쪽 값에 오버로딩 안되어있을 때 유용 (EX: int + 내클래스)

#### STL주요 연산자 오버로딩

함수 호출 연산자 오버로딩
- `Print(10)` 이 나타낼 수 있는 것
	- Print가 그냥 함수 이름
	- Print가 함수 포인터
	- Print가 함수 객체
		- 함수 호출 연산자를 오버로딩 한 경우
		- class나 struct 내에서 `operator()(인수들~)`

배열 인덱스 오버로딩
- `Array[0]` 은 `Array.operator[](0)`
- read, write가능해야 하므로 두가지 버전 만들기
	- const 리턴타입 `operator[](int index)`
	- 리턴타입& `operator[](int index)`
	- const로 선언한 컨테이너가 아니면 read도 const아닌 것으로 사용되었음

메모리 접근(`*`) 클래스 멤버 접근(`->`) 연산자 오버로딩
- Point, PointPtr 만들어서 스마트 포인터 하고 싶을 때
	- PointPtr의 private에 Point* 
		- destructor에서 delete해주면 main에서 따로 delete안해도 됨
	- `*`는 `Point&`, `->`는 `Point*` 리턴타입
	- `*`는 `*ptr`, `->`는 `ptr` 리턴
	- `->` 사용하면 `.operator->()->` 과 같음(약속되어있음)

#### 타입 변환 연산자 오버로딩

타입 변환 두 가지 방법
- `Point p1`
- `p1 = 10 `->생성자 이용
- `int n = p1` ->타입 변환 연산자 오버로딩
- 
- 생성자 이용
	- `Point(int x)` `Point(double x)`등 정의해서 형변환
	- 암시적 생성자 vs 명시적 생성자
		- 생성자로 `Point(int x = 0, int y = 0 )`만들어놓고 `Point p1 = 10`하면 암시적 형변환 일어남
		- `Point p1 = Point(10)`으로 취급 -> 10,0이 들어감
		- 직접 `Point(10)`쳐야만 하도록 만들고 싶으면 생성자 앞에 `explicit` 들어가야함
- 타입 변환 연산자 오버로딩
	- 클래스 안에 `operator int(){ return 10 }` 라고 해주면 클래스를 int로 형변환 가능
		- int, double, 다른 커스텀 클래스 등등 다 가능
		- 생성자처럼 리턴타입 안씀, 중괄호 열고 본문에서 변환할 타입의 값이나 생성자 호출
			- 커스텀 클래스면 `return A()`이런 식으로
		- `operator int() const {~}` 해주면 const/비const 객체에서 모두 사용 가능

#### 함수 객체
- 함수자(Functor)라고 하기도 함
- 주의 : 소괄호 두개씩 쓰이는 경우 `less<int>()(1,2)` -> `less<int>()`까지는 임시 객체 생성, `(1,2)`부분이 `operator().(1,2)`
- 장점
	- 객체의 서명이 같아도 타입이 다를 수 있다
	- 속도가 일반 함수보다 빠르다
	- 함수 주소 전달로 콜백 - 인라인 안됨/함수 객체 전달로 콜백 - 인라인 가능
	- 컴파일러가 쉽게 최적화 가능
#### 함수 포인터
- 함수의 주소를 저장
- 함수의 시그니처와 같게 선언
- `pf()`, `(*pf)()`는 동일한 문장 
	- `pf`, `*pf` 모두 함수의 시작주소를 나타냄
전역 함수 vs 멤버 함수 (함수호출규약이 서로 다름)
- 전역함수 : static 멤버, 전역함수, namespace내의 전역함수
	- ex) `void (*pf)(int, int);`
	- 함수 이름 = 함수 주소값
	- 할당 
		- ex) `pf = Print`
		- ex) `pf = Point::Print`
- 멤버함수 : static아닌 멤버함수들
	- 함수 포인터 선언 ex) `void (Point::\*pf)(int,int) const`
	- 할당
		- `pf = &Point::Print;`
	- 사용
		- `(pt.*pf)(1,2);`
		- `(ppt->*pf)(1,2);`
		- 연산자 우선순위 문제로 추가로 괄호 들어감
#### 클라이언트 코드 vs 서버 코드

기능을 제공받는 쪽 = 클라이언트 코드
기능을 제공하는 쪽 = 서버 코드

클라이언트가 서버 함수 호출 = 콜
서버가 클라이언트 함수 호출 = 콜백
- 서버가 클라이언트의 알고리즘 정책을 반영한다고 함

서버는 클라이언트의 정책 모름 -> 함수 포인터 파라미터로 전달

EX)윈도우의 프로시져, STL의 for_each함수

#### 함수 템플릿, 클래스 템플릿

`template<typename T, int num>` ----typename대신 클래스 쓰는건 옛날 방식

Specialization 할 때는 
```c++
template<>
void Print<Point>(Point p1)

template<>
class Array<Point>
{
	~~
}
```
##### 템플릿 + 함수포인터 + 함수객체로 추가기능 사용 예시
```c++
template<typename IterT, typename Func>
void For_each(IterT begin, IterT end, Func pf)
{
	while(begin !=end)
	{
		pf(*begin++);
	}
}
template<typename T>
struct PrintFunctor
{
	()연산자 오버로딩으로 요소 출력시 중간에 띄어쓰기 할지 줄바꿀지 등등 추가기능 가능
}
```
PrintFunctor를 함수 포인터로 For_each의 파라미터로 사용가능

함수 포인터 데이터 타입은 `void(*)(string)`같은 형태
함수 객체 데이터 타입은 `Print<string>`같은 형태
